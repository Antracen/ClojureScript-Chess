{"version":3,"sources":["haslett/client.cljs"],"mappings":"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","names":["haslett.client/close","stream","var_args","G__27668","haslett.client/connect","js/Error","url","haslett.client.connect","options","protocols","cljs.core.into_array","socket","js/WebSocket","source","cljs.core.async.chan","sink","format","haslett.format/identity","status","cljs.core.async.promise_chan","return","close?","cljs.core/name","_","cljs.core.async.put_BANG_","e","haslett.format/read","cljs.core.async/close!","c__26215__auto__","cljs.core.async.impl.dispatch/run","f__26216__auto__","switch__26036__auto__","state_27718","state_val_27719","statearr-27738","cljs.core.async.impl.ioc-helpers/take!","inst_27713","cljs.core.async.impl.ioc-helpers/return-chan","inst_27694","statearr-27741","statearr-27742","statearr-27743","inst_27704","inst_27705","statearr-27748","statearr-27749","statearr-27750","inst_27710","inst_27711","statearr-27751","statearr-27752","statearr-27753","state-machine__26037__auto__","ret-value__26038__auto__","result__26039__auto__","cljs.core/keyword-identical?","ex__26040__auto__","e27754","statearr-27755","cljs.core/seq","statearr-27756","cljs.core/first","state__26217__auto__","statearr-27757","cljs.core.async.impl.ioc-helpers/USER-START-IDX","cljs.core.async.impl.ioc-helpers/run-state-machine-wrapped","haslett.format/write","p__27765","map__27766","cljs.core/--destructure-map","cljs.core.get","haslett.client/connected?","close-status","cljs.core.async/poll!"],"sourcesContent":["(ns haslett.client\n  \"A namespace for opening WebSockets in ClojureScript.\"\n  (:require [cljs.core.async :as a :refer [<! >!]]\n            [haslett.format :as fmt])\n  (:require-macros [cljs.core.async.macros :refer [go-loop]]))\n\n(defn close\n  \"Close a stream opened by connect.\"\n  [stream]\n  (.close (:socket stream) 1000 \"Closed by creator\")\n  (:close-status stream))\n\n(defn connect\n  \"Create a WebSocket to the specified URL, and returns a 'stream' map of four\n  keys:\n\n    :socket       - contains the WebSocket object\n    :close-status - a promise channel that contains the final close status\n    :source       - a core.async channel to read from\n    :sink         - a core.async channel to write to\n\n  Takes the following options:\n\n    :format      - a formatter from haslett.format\n    :source      - a custom channel to use as the source\n    :sink        - a custom channel to use as the sink\n    :protocols   - passed to the WebSocket, a vector of protocol strings\n    :binary-type - passed to the WebSocket, may be :blob or :arraybuffer\n    :close-chan? - true if channels should be closed if WebSocket is closed\n                   (defaults to true)\n\n  The WebSocket may either be closed directly, or by closing the\n  stream's :sink channel.\"\n  ([url]\n   (connect url {}))\n  ([url options]\n   (let [protocols (into-array (:protocols options []))\n         socket    (js/WebSocket. url protocols)\n         source    (:source options (a/chan))\n         sink      (:sink   options (a/chan))\n         format    (:format options fmt/identity)\n         status    (a/promise-chan)\n         return    (a/promise-chan)\n         close?    (:close-chan? options true)\n         stream    {:socket socket, :source source, :sink sink, :close-status status}]\n     (set! (.-binaryType socket) (name (:binary-type options :arraybuffer)))\n     (set! (.-onopen socket)     (fn [_] (a/put! return stream)))\n     (set! (.-onmessage socket)  (fn [e] (a/put! source (fmt/read format (.-data e)))))\n     (set! (.-onclose socket)    (fn [e]\n                                   (a/put! status {:reason (.-reason e), :code (.-code e)})\n                                   (when close? (a/close! source))\n                                   (when close? (a/close! sink))\n                                   (a/put! return stream)))\n     (go-loop []\n       (when-let [msg (<! sink)]\n         (.send socket (fmt/write format msg))\n         (recur))\n       (close stream))\n     return)))\n\n(defn connected?\n  \"Return true if the stream is currently connected.\"\n  [{:keys [close-status]}]\n  (nil? (a/poll! close-status)))\n"]}